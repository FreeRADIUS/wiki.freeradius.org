Many people have problems configuring FreeRADIUS.  These problems are often due to faulty concepts.  No amount of editing configuration files will correct the faulty concepts.  This page tries to correct that problem.

Here is how things work in RADIUS:

The client sends you a radius authentication request, you don't decide what's in the request, the client does.  The server doesn't decide what's in the request, the client does.  The client is 100% responsible for everything in the request.

The radius server looks the request and says:

''Hmmm... can I do with this request?''

The answer to that depends on what authentication types you have enabled, what the server can look up in a DB, and what is in the request.

The server will do something like this to process the request:

''Unix module, can you handle this one?''

''Pap module, can you handle this one?''

''Mschap module, can you handle this one?''

At some point, one of the modules will say:

''Yes, I see something in the request I recognize.  I can do something!''

The module does this by looking in the request for key attributes, such as MS-CHAP-Challenge (for mschap), or CHAP-Challenge (for chap), or EAP-Message (for eap).  If the module doesn't see anything it recognizes, it does nothing.

For example, if the client sends a request with a User-Password attribute, and pap is enabled. The pap module looks at the request and says

''I see a User-Password, which is what the user entered.  That's nice, but do I have a "known good" password for this user?''

If so, it then compares the local "known good" password to the password as entered by the user.  This is how authentication works.

The "known good" password comes from another module.  The pap module just does PAP authentication, and nothing more.  The benefit of this approach is that the "known good" password can come from the 'users' file, SQL, LDAP, /etc/passwd, external program, etc.  i.e. pretty much anything.

So before the pap module runs, the ldap module will run.   The ldap module will do:

''Hmm... Can I find a "known good" password for this user?''

If so, it will add the "known good" password to the request, so that another module can use it.

But WAIT! What if the client sends a MSCHAP request? What does the radius server say then?

''Well that's a fine kettle of fish! That client has really really tied my hands on this one!''

In this case, the mcshap module looks the request, and finds the MS-CHAP attributes.  It sets the "Auth-Type" to itself (mschap).  A database modules (such as LDAP, above) gets the "known good" password, and adds it to the request.  The mschap module is then run for authentication.  It looks for either a clear text password or nt-hash (why? look at the [http://deployingradius.com/documents/protocols/compatibility.html protocol table]). If one of those haven't been added by a datastore, the mschap module says:

''Sorry, I can't authenticate the user, because I don't have the information I need to validate MSCHAP''

But now the server has run out of options, it's only choice was mschap because that's what the client sent in the request.  The mschap module can't do anything because you didn't give it a useful "known good" password . So the server has no choice but to reject the request.  The MSCHAP data might be correct, but the server has no way to know that.  So it replies with a reject.
