Coding standards
----------------

By and large, the goal is to have consistent, clear code.  All code should share a common style, format, choice of function / variable names, etc.  This means that people looking at the code see the *code*, and not the wildly different coding styles.

Code should be commented.  There are over 100K LoC in the server, and it's impossible to always remember *why* things are done the way they are.  The comments should explain the choices behind the code, the goal, or philosophy, or the "gotcha's".

Function naming conventions
===========================

Verb / noun order
^^^^^^^^^^^^^^^^^
Nouns should always precede verbs ``<prefix>_<noun>_<verb>[_<verb qualifiers>]``.

Good
```c
fr_request_alloc()
fr_dict_find_by_name()
python_interp_exec()
```

Bad
```c
do_python()
rest_parse_pairs()
```

Name component separation 
^^^^^^^^^^^^^^^^^^^^^^^^^

Name components should be separated by underscores.

- frPairFind -> bad
- frpairfind -> bad
- fr_pairfind -> bad
- fr_pair_find -> good

Prefixes / namespaces
^^^^^^^^^^^^^^^^^^^^^

Protocol library ``fr_``
""""""""""""""""""""""""
All functions in the protocol library should be prefixed with ``fr``. The rationale is that as libfreeradius is a library intended to be used by 3rd party applications it requires a namespace to avoid conflicts.

Server library ``<group>_``
"""""""""""""""""""""""""""
Functions in the server library should not have a global prefix, but should use a common prefix i.e. functions which manipulate value pairs should use the ``pair_`` prefix, dictionary functions should use the ``dict_`` prefix.

Modules
"""""""
Public functions should use the ``mod_`` prefix, e.g. ``mod_authorize``, ``mod_authentication``, ``mod_instantiate``. If the module uses its own library, those functions should be prefixed with the name of the module e.g. ``python_``, ``rest_``, ``eap_``.

Ideally, all of the functions in a module should be ``static``.  If they cannot be that, the function name prefixes given above are *required*.

Instantiation and destruction
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Library initialisations functions should use the verb ``init``.
Structure allocation functions should use the verb ``alloc``. ``create`` should not be used.

Explicit ``free`` or ``destroy`` functions should be avoided, and talloc destructors used wherever possible. Talloc destructor functions should be static and be prefixed with ``_`` to mark them as private e.g. ``_fr_pair_free()``

Return codes
============

Boolean
^^^^^^^

``bool`` is used where the function is answering a true/false question. A good example is the ``is_whitespace`` function, which checks if the entire string is made up of whitespace.

Integer
^^^^^^^

Should be used for most functions. Negative integers indicate failure, zero indicates success, positive integers indicate success with caveats.

If you find a function returns significant (> 4) integer values, you should define C preprocess macros, and an enum type so that it's clear in calling code what the different values mean.

Pointer
^^^^^^^

Used only for allocation functions where there's a single simple failure mode (in which case NULL is returned). For more complicated failures the function should return an integer, and write a pointer to the allocated memory via one of the arguments.

e.g.

```c
int complicated_memory_alloc(TALLOC_CTX *ctx, my_structure_t **out, int arg0, int arg1)
{
	my_structure_t *structure.

	if (arg0 == 0) {
		fr_strerror_printf("Invalid parameter, arg0 must be greater than 0");
		return -2;
	}	

	structure = talloc(ctx, my_structure_t);
	if (!structure) return -1;

	return 0;
}
```

Argument order
==============

Arguments should be in the following order

- TALLOC_CTX
- Arguments that return data to the caller ([out] arguments in doxygen parlence)
- Arguments for passing data to the function.

For modules the instance data pointer should be directly before the ``REQUEST *`` pointer.